// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package auto_scaling_group

import (
	"context"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strings"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcondition "github.com/aws-controllers-k8s/runtime/pkg/condition"
	ackerr "github.com/aws-controllers-k8s/runtime/pkg/errors"
	ackrequeue "github.com/aws-controllers-k8s/runtime/pkg/requeue"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/autoscaling"
	svcsdktypes "github.com/aws/aws-sdk-go-v2/service/autoscaling/types"
	smithy "github.com/aws/smithy-go"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	svcapitypes "github.com/aws-controllers-k8s/autoscaling-controller/apis/v1alpha1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
	_ = strings.ToLower("")
	_ = &svcsdk.Client{}
	_ = &svcapitypes.AutoScalingGroup{}
	_ = ackv1alpha1.AWSAccountID("")
	_ = &ackerr.NotFound
	_ = &ackcondition.NotManagedMessage
	_ = &reflect.Value{}
	_ = fmt.Sprintf("")
	_ = &ackrequeue.NoRequeue{}
	_ = &aws.Config{}
)

// sdkFind returns SDK-specific information about a supplied resource
func (rm *resourceManager) sdkFind(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkFind")
	defer func() {
		exit(err)
	}()
	// If any required fields in the input shape are missing, AWS resource is
	// not created yet. Return NotFound here to indicate to callers that the
	// resource isn't yet created.
	if rm.requiredFieldsMissingFromReadManyInput(r) {
		return nil, ackerr.NotFound
	}

	input, err := rm.newListRequestPayload(r)
	if err != nil {
		return nil, err
	}
	var resp *svcsdk.DescribeAutoScalingGroupsOutput
	resp, err = rm.sdkapi.DescribeAutoScalingGroups(ctx, input)
	rm.metrics.RecordAPICall("READ_MANY", "DescribeAutoScalingGroups", err)
	if err != nil {
		var awsErr smithy.APIError
		if errors.As(err, &awsErr) && awsErr.ErrorCode() == "UNKNOWN" {
			return nil, ackerr.NotFound
		}
		return nil, err
	}

	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	found := false
	for _, elem := range resp.AutoScalingGroups {
		if elem.AutoScalingGroupARN != nil {
			if ko.Status.ACKResourceMetadata == nil {
				ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
			}
			tmpARN := ackv1alpha1.AWSResourceName(*elem.AutoScalingGroupARN)
			ko.Status.ACKResourceMetadata.ARN = &tmpARN
		}
		if elem.AutoScalingGroupName != nil {
			ko.Spec.AutoScalingGroupName = elem.AutoScalingGroupName
		} else {
			ko.Spec.AutoScalingGroupName = nil
		}
		if elem.AvailabilityZoneDistribution != nil {
			f2 := &svcapitypes.AvailabilityZoneDistribution{}
			if elem.AvailabilityZoneDistribution.CapacityDistributionStrategy != "" {
				f2.CapacityDistributionStrategy = aws.String(string(elem.AvailabilityZoneDistribution.CapacityDistributionStrategy))
			}
			ko.Spec.AvailabilityZoneDistribution = f2
		} else {
			ko.Spec.AvailabilityZoneDistribution = nil
		}
		if elem.AvailabilityZoneImpairmentPolicy != nil {
			f3 := &svcapitypes.AvailabilityZoneImpairmentPolicy{}
			if elem.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior != "" {
				f3.ImpairedZoneHealthCheckBehavior = aws.String(string(elem.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior))
			}
			if elem.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled != nil {
				f3.ZonalShiftEnabled = elem.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled
			}
			ko.Spec.AvailabilityZoneImpairmentPolicy = f3
		} else {
			ko.Spec.AvailabilityZoneImpairmentPolicy = nil
		}
		if elem.AvailabilityZones != nil {
			ko.Spec.AvailabilityZones = aws.StringSlice(elem.AvailabilityZones)
		} else {
			ko.Spec.AvailabilityZones = nil
		}
		if elem.CapacityRebalance != nil {
			ko.Spec.CapacityRebalance = elem.CapacityRebalance
		} else {
			ko.Spec.CapacityRebalance = nil
		}
		if elem.CapacityReservationSpecification != nil {
			f6 := &svcapitypes.CapacityReservationSpecification{}
			if elem.CapacityReservationSpecification.CapacityReservationPreference != "" {
				f6.CapacityReservationPreference = aws.String(string(elem.CapacityReservationSpecification.CapacityReservationPreference))
			}
			if elem.CapacityReservationSpecification.CapacityReservationTarget != nil {
				f6f1 := &svcapitypes.CapacityReservationTarget{}
				if elem.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIds != nil {
					f6f1.CapacityReservationIDs = aws.StringSlice(elem.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIds)
				}
				if elem.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupArns != nil {
					f6f1.CapacityReservationResourceGroupARNs = aws.StringSlice(elem.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupArns)
				}
				f6.CapacityReservationTarget = f6f1
			}
			ko.Spec.CapacityReservationSpecification = f6
		} else {
			ko.Spec.CapacityReservationSpecification = nil
		}
		if elem.Context != nil {
			ko.Spec.Context = elem.Context
		} else {
			ko.Spec.Context = nil
		}
		if elem.DefaultCooldown != nil {
			defaultCooldownCopy := int64(*elem.DefaultCooldown)
			ko.Spec.DefaultCooldown = &defaultCooldownCopy
		} else {
			ko.Spec.DefaultCooldown = nil
		}
		if elem.DefaultInstanceWarmup != nil {
			defaultInstanceWarmupCopy := int64(*elem.DefaultInstanceWarmup)
			ko.Spec.DefaultInstanceWarmup = &defaultInstanceWarmupCopy
		} else {
			ko.Spec.DefaultInstanceWarmup = nil
		}
		if elem.DesiredCapacity != nil {
			desiredCapacityCopy := int64(*elem.DesiredCapacity)
			ko.Spec.DesiredCapacity = &desiredCapacityCopy
		} else {
			ko.Spec.DesiredCapacity = nil
		}
		if elem.DesiredCapacityType != nil {
			ko.Spec.DesiredCapacityType = elem.DesiredCapacityType
		} else {
			ko.Spec.DesiredCapacityType = nil
		}
		if elem.HealthCheckGracePeriod != nil {
			healthCheckGracePeriodCopy := int64(*elem.HealthCheckGracePeriod)
			ko.Spec.HealthCheckGracePeriod = &healthCheckGracePeriodCopy
		} else {
			ko.Spec.HealthCheckGracePeriod = nil
		}
		if elem.HealthCheckType != nil {
			ko.Spec.HealthCheckType = elem.HealthCheckType
		} else {
			ko.Spec.HealthCheckType = nil
		}
		if elem.InstanceLifecyclePolicy != nil {
			f16 := &svcapitypes.InstanceLifecyclePolicy{}
			if elem.InstanceLifecyclePolicy.RetentionTriggers != nil {
				f16f0 := &svcapitypes.RetentionTriggers{}
				if elem.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon != "" {
					f16f0.TerminateHookAbandon = aws.String(string(elem.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon))
				}
				f16.RetentionTriggers = f16f0
			}
			ko.Spec.InstanceLifecyclePolicy = f16
		} else {
			ko.Spec.InstanceLifecyclePolicy = nil
		}
		if elem.InstanceMaintenancePolicy != nil {
			f17 := &svcapitypes.InstanceMaintenancePolicy{}
			if elem.InstanceMaintenancePolicy.MaxHealthyPercentage != nil {
				maxHealthyPercentageCopy := int64(*elem.InstanceMaintenancePolicy.MaxHealthyPercentage)
				f17.MaxHealthyPercentage = &maxHealthyPercentageCopy
			}
			if elem.InstanceMaintenancePolicy.MinHealthyPercentage != nil {
				minHealthyPercentageCopy := int64(*elem.InstanceMaintenancePolicy.MinHealthyPercentage)
				f17.MinHealthyPercentage = &minHealthyPercentageCopy
			}
			ko.Spec.InstanceMaintenancePolicy = f17
		} else {
			ko.Spec.InstanceMaintenancePolicy = nil
		}
		if elem.LaunchConfigurationName != nil {
			ko.Spec.LaunchConfigurationName = elem.LaunchConfigurationName
		} else {
			ko.Spec.LaunchConfigurationName = nil
		}
		if elem.LaunchTemplate != nil {
			f20 := &svcapitypes.LaunchTemplateSpecification{}
			if elem.LaunchTemplate.LaunchTemplateId != nil {
				f20.LaunchTemplateID = elem.LaunchTemplate.LaunchTemplateId
			}
			if elem.LaunchTemplate.LaunchTemplateName != nil {
				f20.LaunchTemplateName = elem.LaunchTemplate.LaunchTemplateName
			}
			if elem.LaunchTemplate.Version != nil {
				f20.Version = elem.LaunchTemplate.Version
			}
			ko.Spec.LaunchTemplate = f20
		} else {
			ko.Spec.LaunchTemplate = nil
		}
		if elem.LoadBalancerNames != nil {
			ko.Spec.LoadBalancerNames = aws.StringSlice(elem.LoadBalancerNames)
		} else {
			ko.Spec.LoadBalancerNames = nil
		}
		if elem.MaxInstanceLifetime != nil {
			maxInstanceLifetimeCopy := int64(*elem.MaxInstanceLifetime)
			ko.Spec.MaxInstanceLifetime = &maxInstanceLifetimeCopy
		} else {
			ko.Spec.MaxInstanceLifetime = nil
		}
		if elem.MaxSize != nil {
			maxSizeCopy := int64(*elem.MaxSize)
			ko.Spec.MaxSize = &maxSizeCopy
		} else {
			ko.Spec.MaxSize = nil
		}
		if elem.MinSize != nil {
			minSizeCopy := int64(*elem.MinSize)
			ko.Spec.MinSize = &minSizeCopy
		} else {
			ko.Spec.MinSize = nil
		}
		if elem.MixedInstancesPolicy != nil {
			f25 := &svcapitypes.MixedInstancesPolicy{}
			if elem.MixedInstancesPolicy.InstancesDistribution != nil {
				f25f0 := &svcapitypes.InstancesDistribution{}
				if elem.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy != nil {
					f25f0.OnDemandAllocationStrategy = elem.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy
				}
				if elem.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity != nil {
					onDemandBaseCapacityCopy := int64(*elem.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity)
					f25f0.OnDemandBaseCapacity = &onDemandBaseCapacityCopy
				}
				if elem.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity != nil {
					onDemandPercentageAboveBaseCapacityCopy := int64(*elem.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity)
					f25f0.OnDemandPercentageAboveBaseCapacity = &onDemandPercentageAboveBaseCapacityCopy
				}
				if elem.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy != nil {
					f25f0.SpotAllocationStrategy = elem.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy
				}
				if elem.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools != nil {
					spotInstancePoolsCopy := int64(*elem.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools)
					f25f0.SpotInstancePools = &spotInstancePoolsCopy
				}
				if elem.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice != nil {
					f25f0.SpotMaxPrice = elem.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice
				}
				f25.InstancesDistribution = f25f0
			}
			if elem.MixedInstancesPolicy.LaunchTemplate != nil {
				f25f1 := &svcapitypes.LaunchTemplate{}
				if elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification != nil {
					f25f1f0 := &svcapitypes.LaunchTemplateSpecification{}
					if elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId != nil {
						f25f1f0.LaunchTemplateID = elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId
					}
					if elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName != nil {
						f25f1f0.LaunchTemplateName = elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName
					}
					if elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version != nil {
						f25f1f0.Version = elem.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version
					}
					f25f1.LaunchTemplateSpecification = f25f1f0
				}
				if elem.MixedInstancesPolicy.LaunchTemplate.Overrides != nil {
					f25f1f1 := []*svcapitypes.LaunchTemplateOverrides{}
					for _, f25f1f1iter := range elem.MixedInstancesPolicy.LaunchTemplate.Overrides {
						f25f1f1elem := &svcapitypes.LaunchTemplateOverrides{}
						if f25f1f1iter.ImageId != nil {
							f25f1f1elem.ImageID = f25f1f1iter.ImageId
						}
						if f25f1f1iter.InstanceRequirements != nil {
							f25f1f1elemf1 := &svcapitypes.InstanceRequirements{}
							if f25f1f1iter.InstanceRequirements.AcceleratorCount != nil {
								f25f1f1elemf1f0 := &svcapitypes.AcceleratorCountRequest{}
								if f25f1f1iter.InstanceRequirements.AcceleratorCount.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.AcceleratorCount.Max)
									f25f1f1elemf1f0.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.AcceleratorCount.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.AcceleratorCount.Min)
									f25f1f1elemf1f0.Min = &minCopy
								}
								f25f1f1elemf1.AcceleratorCount = f25f1f1elemf1f0
							}
							if f25f1f1iter.InstanceRequirements.AcceleratorManufacturers != nil {
								f25f1f1elemf1f1 := []*string{}
								for _, f25f1f1elemf1f1iter := range f25f1f1iter.InstanceRequirements.AcceleratorManufacturers {
									var f25f1f1elemf1f1elem *string
									f25f1f1elemf1f1elem = aws.String(string(f25f1f1elemf1f1iter))
									f25f1f1elemf1f1 = append(f25f1f1elemf1f1, f25f1f1elemf1f1elem)
								}
								f25f1f1elemf1.AcceleratorManufacturers = f25f1f1elemf1f1
							}
							if f25f1f1iter.InstanceRequirements.AcceleratorNames != nil {
								f25f1f1elemf1f2 := []*string{}
								for _, f25f1f1elemf1f2iter := range f25f1f1iter.InstanceRequirements.AcceleratorNames {
									var f25f1f1elemf1f2elem *string
									f25f1f1elemf1f2elem = aws.String(string(f25f1f1elemf1f2iter))
									f25f1f1elemf1f2 = append(f25f1f1elemf1f2, f25f1f1elemf1f2elem)
								}
								f25f1f1elemf1.AcceleratorNames = f25f1f1elemf1f2
							}
							if f25f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB != nil {
								f25f1f1elemf1f3 := &svcapitypes.AcceleratorTotalMemoryMiBRequest{}
								if f25f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max)
									f25f1f1elemf1f3.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min)
									f25f1f1elemf1f3.Min = &minCopy
								}
								f25f1f1elemf1.AcceleratorTotalMemoryMiB = f25f1f1elemf1f3
							}
							if f25f1f1iter.InstanceRequirements.AcceleratorTypes != nil {
								f25f1f1elemf1f4 := []*string{}
								for _, f25f1f1elemf1f4iter := range f25f1f1iter.InstanceRequirements.AcceleratorTypes {
									var f25f1f1elemf1f4elem *string
									f25f1f1elemf1f4elem = aws.String(string(f25f1f1elemf1f4iter))
									f25f1f1elemf1f4 = append(f25f1f1elemf1f4, f25f1f1elemf1f4elem)
								}
								f25f1f1elemf1.AcceleratorTypes = f25f1f1elemf1f4
							}
							if f25f1f1iter.InstanceRequirements.AllowedInstanceTypes != nil {
								f25f1f1elemf1.AllowedInstanceTypes = aws.StringSlice(f25f1f1iter.InstanceRequirements.AllowedInstanceTypes)
							}
							if f25f1f1iter.InstanceRequirements.BareMetal != "" {
								f25f1f1elemf1.BareMetal = aws.String(string(f25f1f1iter.InstanceRequirements.BareMetal))
							}
							if f25f1f1iter.InstanceRequirements.BaselineEbsBandwidthMbps != nil {
								f25f1f1elemf1f7 := &svcapitypes.BaselineEBSBandwidthMbpsRequest{}
								if f25f1f1iter.InstanceRequirements.BaselineEbsBandwidthMbps.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.BaselineEbsBandwidthMbps.Max)
									f25f1f1elemf1f7.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.BaselineEbsBandwidthMbps.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.BaselineEbsBandwidthMbps.Min)
									f25f1f1elemf1f7.Min = &minCopy
								}
								f25f1f1elemf1.BaselineEBSBandwidthMbps = f25f1f1elemf1f7
							}
							if f25f1f1iter.InstanceRequirements.BaselinePerformanceFactors != nil {
								f25f1f1elemf1f8 := &svcapitypes.BaselinePerformanceFactorsRequest{}
								if f25f1f1iter.InstanceRequirements.BaselinePerformanceFactors.Cpu != nil {
									f25f1f1elemf1f8f0 := &svcapitypes.CPUPerformanceFactorRequest{}
									if f25f1f1iter.InstanceRequirements.BaselinePerformanceFactors.Cpu.References != nil {
										f25f1f1elemf1f8f0f0 := []*svcapitypes.PerformanceFactorReferenceRequest{}
										for _, f25f1f1elemf1f8f0f0iter := range f25f1f1iter.InstanceRequirements.BaselinePerformanceFactors.Cpu.References {
											f25f1f1elemf1f8f0f0elem := &svcapitypes.PerformanceFactorReferenceRequest{}
											if f25f1f1elemf1f8f0f0iter.InstanceFamily != nil {
												f25f1f1elemf1f8f0f0elem.InstanceFamily = f25f1f1elemf1f8f0f0iter.InstanceFamily
											}
											f25f1f1elemf1f8f0f0 = append(f25f1f1elemf1f8f0f0, f25f1f1elemf1f8f0f0elem)
										}
										f25f1f1elemf1f8f0.References = f25f1f1elemf1f8f0f0
									}
									f25f1f1elemf1f8.CPU = f25f1f1elemf1f8f0
								}
								f25f1f1elemf1.BaselinePerformanceFactors = f25f1f1elemf1f8
							}
							if f25f1f1iter.InstanceRequirements.BurstablePerformance != "" {
								f25f1f1elemf1.BurstablePerformance = aws.String(string(f25f1f1iter.InstanceRequirements.BurstablePerformance))
							}
							if f25f1f1iter.InstanceRequirements.CpuManufacturers != nil {
								f25f1f1elemf1f10 := []*string{}
								for _, f25f1f1elemf1f10iter := range f25f1f1iter.InstanceRequirements.CpuManufacturers {
									var f25f1f1elemf1f10elem *string
									f25f1f1elemf1f10elem = aws.String(string(f25f1f1elemf1f10iter))
									f25f1f1elemf1f10 = append(f25f1f1elemf1f10, f25f1f1elemf1f10elem)
								}
								f25f1f1elemf1.CPUManufacturers = f25f1f1elemf1f10
							}
							if f25f1f1iter.InstanceRequirements.ExcludedInstanceTypes != nil {
								f25f1f1elemf1.ExcludedInstanceTypes = aws.StringSlice(f25f1f1iter.InstanceRequirements.ExcludedInstanceTypes)
							}
							if f25f1f1iter.InstanceRequirements.InstanceGenerations != nil {
								f25f1f1elemf1f12 := []*string{}
								for _, f25f1f1elemf1f12iter := range f25f1f1iter.InstanceRequirements.InstanceGenerations {
									var f25f1f1elemf1f12elem *string
									f25f1f1elemf1f12elem = aws.String(string(f25f1f1elemf1f12iter))
									f25f1f1elemf1f12 = append(f25f1f1elemf1f12, f25f1f1elemf1f12elem)
								}
								f25f1f1elemf1.InstanceGenerations = f25f1f1elemf1f12
							}
							if f25f1f1iter.InstanceRequirements.LocalStorage != "" {
								f25f1f1elemf1.LocalStorage = aws.String(string(f25f1f1iter.InstanceRequirements.LocalStorage))
							}
							if f25f1f1iter.InstanceRequirements.LocalStorageTypes != nil {
								f25f1f1elemf1f14 := []*string{}
								for _, f25f1f1elemf1f14iter := range f25f1f1iter.InstanceRequirements.LocalStorageTypes {
									var f25f1f1elemf1f14elem *string
									f25f1f1elemf1f14elem = aws.String(string(f25f1f1elemf1f14iter))
									f25f1f1elemf1f14 = append(f25f1f1elemf1f14, f25f1f1elemf1f14elem)
								}
								f25f1f1elemf1.LocalStorageTypes = f25f1f1elemf1f14
							}
							if f25f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice != nil {
								maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy := int64(*f25f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice)
								f25f1f1elemf1.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice = &maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy
							}
							if f25f1f1iter.InstanceRequirements.MemoryGiBPerVCpu != nil {
								f25f1f1elemf1f16 := &svcapitypes.MemoryGiBPerVCPURequest{}
								if f25f1f1iter.InstanceRequirements.MemoryGiBPerVCpu.Max != nil {
									f25f1f1elemf1f16.Max = f25f1f1iter.InstanceRequirements.MemoryGiBPerVCpu.Max
								}
								if f25f1f1iter.InstanceRequirements.MemoryGiBPerVCpu.Min != nil {
									f25f1f1elemf1f16.Min = f25f1f1iter.InstanceRequirements.MemoryGiBPerVCpu.Min
								}
								f25f1f1elemf1.MemoryGiBPerVCPU = f25f1f1elemf1f16
							}
							if f25f1f1iter.InstanceRequirements.MemoryMiB != nil {
								f25f1f1elemf1f17 := &svcapitypes.MemoryMiBRequest{}
								if f25f1f1iter.InstanceRequirements.MemoryMiB.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.MemoryMiB.Max)
									f25f1f1elemf1f17.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.MemoryMiB.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.MemoryMiB.Min)
									f25f1f1elemf1f17.Min = &minCopy
								}
								f25f1f1elemf1.MemoryMiB = f25f1f1elemf1f17
							}
							if f25f1f1iter.InstanceRequirements.NetworkBandwidthGbps != nil {
								f25f1f1elemf1f18 := &svcapitypes.NetworkBandwidthGbpsRequest{}
								if f25f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max != nil {
									f25f1f1elemf1f18.Max = f25f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max
								}
								if f25f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min != nil {
									f25f1f1elemf1f18.Min = f25f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min
								}
								f25f1f1elemf1.NetworkBandwidthGbps = f25f1f1elemf1f18
							}
							if f25f1f1iter.InstanceRequirements.NetworkInterfaceCount != nil {
								f25f1f1elemf1f19 := &svcapitypes.NetworkInterfaceCountRequest{}
								if f25f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max)
									f25f1f1elemf1f19.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min)
									f25f1f1elemf1f19.Min = &minCopy
								}
								f25f1f1elemf1.NetworkInterfaceCount = f25f1f1elemf1f19
							}
							if f25f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice != nil {
								onDemandMaxPricePercentageOverLowestPriceCopy := int64(*f25f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice)
								f25f1f1elemf1.OnDemandMaxPricePercentageOverLowestPrice = &onDemandMaxPricePercentageOverLowestPriceCopy
							}
							if f25f1f1iter.InstanceRequirements.RequireHibernateSupport != nil {
								f25f1f1elemf1.RequireHibernateSupport = f25f1f1iter.InstanceRequirements.RequireHibernateSupport
							}
							if f25f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice != nil {
								spotMaxPricePercentageOverLowestPriceCopy := int64(*f25f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice)
								f25f1f1elemf1.SpotMaxPricePercentageOverLowestPrice = &spotMaxPricePercentageOverLowestPriceCopy
							}
							if f25f1f1iter.InstanceRequirements.TotalLocalStorageGB != nil {
								f25f1f1elemf1f23 := &svcapitypes.TotalLocalStorageGBRequest{}
								if f25f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max != nil {
									f25f1f1elemf1f23.Max = f25f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max
								}
								if f25f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min != nil {
									f25f1f1elemf1f23.Min = f25f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min
								}
								f25f1f1elemf1.TotalLocalStorageGB = f25f1f1elemf1f23
							}
							if f25f1f1iter.InstanceRequirements.VCpuCount != nil {
								f25f1f1elemf1f24 := &svcapitypes.VCPUCountRequest{}
								if f25f1f1iter.InstanceRequirements.VCpuCount.Max != nil {
									maxCopy := int64(*f25f1f1iter.InstanceRequirements.VCpuCount.Max)
									f25f1f1elemf1f24.Max = &maxCopy
								}
								if f25f1f1iter.InstanceRequirements.VCpuCount.Min != nil {
									minCopy := int64(*f25f1f1iter.InstanceRequirements.VCpuCount.Min)
									f25f1f1elemf1f24.Min = &minCopy
								}
								f25f1f1elemf1.VCPUCount = f25f1f1elemf1f24
							}
							f25f1f1elem.InstanceRequirements = f25f1f1elemf1
						}
						if f25f1f1iter.InstanceType != nil {
							f25f1f1elem.InstanceType = f25f1f1iter.InstanceType
						}
						if f25f1f1iter.LaunchTemplateSpecification != nil {
							f25f1f1elemf3 := &svcapitypes.LaunchTemplateSpecification{}
							if f25f1f1iter.LaunchTemplateSpecification.LaunchTemplateId != nil {
								f25f1f1elemf3.LaunchTemplateID = f25f1f1iter.LaunchTemplateSpecification.LaunchTemplateId
							}
							if f25f1f1iter.LaunchTemplateSpecification.LaunchTemplateName != nil {
								f25f1f1elemf3.LaunchTemplateName = f25f1f1iter.LaunchTemplateSpecification.LaunchTemplateName
							}
							if f25f1f1iter.LaunchTemplateSpecification.Version != nil {
								f25f1f1elemf3.Version = f25f1f1iter.LaunchTemplateSpecification.Version
							}
							f25f1f1elem.LaunchTemplateSpecification = f25f1f1elemf3
						}
						if f25f1f1iter.WeightedCapacity != nil {
							f25f1f1elem.WeightedCapacity = f25f1f1iter.WeightedCapacity
						}
						f25f1f1 = append(f25f1f1, f25f1f1elem)
					}
					f25f1.Overrides = f25f1f1
				}
				f25.LaunchTemplate = f25f1
			}
			ko.Spec.MixedInstancesPolicy = f25
		} else {
			ko.Spec.MixedInstancesPolicy = nil
		}
		if elem.NewInstancesProtectedFromScaleIn != nil {
			ko.Spec.NewInstancesProtectedFromScaleIn = elem.NewInstancesProtectedFromScaleIn
		} else {
			ko.Spec.NewInstancesProtectedFromScaleIn = nil
		}
		if elem.PlacementGroup != nil {
			ko.Spec.PlacementGroup = elem.PlacementGroup
		} else {
			ko.Spec.PlacementGroup = nil
		}
		if elem.ServiceLinkedRoleARN != nil {
			ko.Spec.ServiceLinkedRoleARN = elem.ServiceLinkedRoleARN
		} else {
			ko.Spec.ServiceLinkedRoleARN = nil
		}
		if elem.Tags != nil {
			f32 := []*svcapitypes.Tag{}
			for _, f32iter := range elem.Tags {
				f32elem := &svcapitypes.Tag{}
				if f32iter.Key != nil {
					f32elem.Key = f32iter.Key
				}
				if f32iter.PropagateAtLaunch != nil {
					f32elem.PropagateAtLaunch = f32iter.PropagateAtLaunch
				}
				if f32iter.ResourceId != nil {
					f32elem.ResourceID = f32iter.ResourceId
				}
				if f32iter.ResourceType != nil {
					f32elem.ResourceType = f32iter.ResourceType
				}
				if f32iter.Value != nil {
					f32elem.Value = f32iter.Value
				}
				f32 = append(f32, f32elem)
			}
			ko.Spec.Tags = f32
		} else {
			ko.Spec.Tags = nil
		}
		if elem.TargetGroupARNs != nil {
			ko.Spec.TargetGroupARNs = aws.StringSlice(elem.TargetGroupARNs)
		} else {
			ko.Spec.TargetGroupARNs = nil
		}
		if elem.TerminationPolicies != nil {
			ko.Spec.TerminationPolicies = aws.StringSlice(elem.TerminationPolicies)
		} else {
			ko.Spec.TerminationPolicies = nil
		}
		if elem.TrafficSources != nil {
			f35 := []*svcapitypes.TrafficSourceIdentifier{}
			for _, f35iter := range elem.TrafficSources {
				f35elem := &svcapitypes.TrafficSourceIdentifier{}
				if f35iter.Identifier != nil {
					f35elem.Identifier = f35iter.Identifier
				}
				if f35iter.Type != nil {
					f35elem.Type = f35iter.Type
				}
				f35 = append(f35, f35elem)
			}
			ko.Spec.TrafficSources = f35
		} else {
			ko.Spec.TrafficSources = nil
		}
		if elem.VPCZoneIdentifier != nil {
			ko.Spec.VPCZoneIdentifier = elem.VPCZoneIdentifier
		} else {
			ko.Spec.VPCZoneIdentifier = nil
		}
		found = true
		break
	}
	if !found {
		return nil, ackerr.NotFound
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// requiredFieldsMissingFromReadManyInput returns true if there are any fields
// for the ReadMany Input shape that are required but not present in the
// resource's Spec or Status
func (rm *resourceManager) requiredFieldsMissingFromReadManyInput(
	r *resource,
) bool {
	return r.ko.Spec.AutoScalingGroupName == nil

}

// newListRequestPayload returns SDK-specific struct for the HTTP request
// payload of the List API call for the resource
func (rm *resourceManager) newListRequestPayload(
	r *resource,
) (*svcsdk.DescribeAutoScalingGroupsInput, error) {
	res := &svcsdk.DescribeAutoScalingGroupsInput{}

	if r.ko.Spec.AutoScalingGroupName != nil {
		f0 := []string{}
		f0 = append(f0, *r.ko.Spec.AutoScalingGroupName)
		res.AutoScalingGroupNames = f0
	}

	return res, nil
}

// sdkCreate creates the supplied resource in the backend AWS service API and
// returns a copy of the resource with resource fields (in both Spec and
// Status) filled in with values from the CREATE API operation's Output shape.
func (rm *resourceManager) sdkCreate(
	ctx context.Context,
	desired *resource,
) (created *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkCreate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newCreateRequestPayload(ctx, desired)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.CreateAutoScalingGroupOutput
	_ = resp
	resp, err = rm.sdkapi.CreateAutoScalingGroup(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "CreateAutoScalingGroup", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	rm.setStatusDefaults(ko)
	if ko.Spec.Tags != nil {
		ackcondition.SetSynced(&resource{ko}, corev1.ConditionFalse, nil, nil)
	}

	return &resource{ko}, nil
}

// newCreateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Create API call for the resource
func (rm *resourceManager) newCreateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.CreateAutoScalingGroupInput, error) {
	res := &svcsdk.CreateAutoScalingGroupInput{}

	if r.ko.Spec.AutoScalingGroupName != nil {
		res.AutoScalingGroupName = r.ko.Spec.AutoScalingGroupName
	}
	if r.ko.Spec.AvailabilityZoneDistribution != nil {
		f1 := &svcsdktypes.AvailabilityZoneDistribution{}
		if r.ko.Spec.AvailabilityZoneDistribution.CapacityDistributionStrategy != nil {
			f1.CapacityDistributionStrategy = svcsdktypes.CapacityDistributionStrategy(*r.ko.Spec.AvailabilityZoneDistribution.CapacityDistributionStrategy)
		}
		res.AvailabilityZoneDistribution = f1
	}
	if r.ko.Spec.AvailabilityZoneImpairmentPolicy != nil {
		f2 := &svcsdktypes.AvailabilityZoneImpairmentPolicy{}
		if r.ko.Spec.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior != nil {
			f2.ImpairedZoneHealthCheckBehavior = svcsdktypes.ImpairedZoneHealthCheckBehavior(*r.ko.Spec.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior)
		}
		if r.ko.Spec.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled != nil {
			f2.ZonalShiftEnabled = r.ko.Spec.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled
		}
		res.AvailabilityZoneImpairmentPolicy = f2
	}
	if r.ko.Spec.AvailabilityZones != nil {
		res.AvailabilityZones = aws.ToStringSlice(r.ko.Spec.AvailabilityZones)
	}
	if r.ko.Spec.CapacityRebalance != nil {
		res.CapacityRebalance = r.ko.Spec.CapacityRebalance
	}
	if r.ko.Spec.CapacityReservationSpecification != nil {
		f5 := &svcsdktypes.CapacityReservationSpecification{}
		if r.ko.Spec.CapacityReservationSpecification.CapacityReservationPreference != nil {
			f5.CapacityReservationPreference = svcsdktypes.CapacityReservationPreference(*r.ko.Spec.CapacityReservationSpecification.CapacityReservationPreference)
		}
		if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget != nil {
			f5f1 := &svcsdktypes.CapacityReservationTarget{}
			if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIDs != nil {
				f5f1.CapacityReservationIds = aws.ToStringSlice(r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIDs)
			}
			if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupARNs != nil {
				f5f1.CapacityReservationResourceGroupArns = aws.ToStringSlice(r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupARNs)
			}
			f5.CapacityReservationTarget = f5f1
		}
		res.CapacityReservationSpecification = f5
	}
	if r.ko.Spec.Context != nil {
		res.Context = r.ko.Spec.Context
	}
	if r.ko.Spec.DefaultCooldown != nil {
		defaultCooldownCopy0 := *r.ko.Spec.DefaultCooldown
		if defaultCooldownCopy0 > math.MaxInt32 || defaultCooldownCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DefaultCooldown is of type int32")
		}
		defaultCooldownCopy := int32(defaultCooldownCopy0)
		res.DefaultCooldown = &defaultCooldownCopy
	}
	if r.ko.Spec.DefaultInstanceWarmup != nil {
		defaultInstanceWarmupCopy0 := *r.ko.Spec.DefaultInstanceWarmup
		if defaultInstanceWarmupCopy0 > math.MaxInt32 || defaultInstanceWarmupCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DefaultInstanceWarmup is of type int32")
		}
		defaultInstanceWarmupCopy := int32(defaultInstanceWarmupCopy0)
		res.DefaultInstanceWarmup = &defaultInstanceWarmupCopy
	}
	if r.ko.Spec.DesiredCapacity != nil {
		desiredCapacityCopy0 := *r.ko.Spec.DesiredCapacity
		if desiredCapacityCopy0 > math.MaxInt32 || desiredCapacityCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DesiredCapacity is of type int32")
		}
		desiredCapacityCopy := int32(desiredCapacityCopy0)
		res.DesiredCapacity = &desiredCapacityCopy
	}
	if r.ko.Spec.DesiredCapacityType != nil {
		res.DesiredCapacityType = r.ko.Spec.DesiredCapacityType
	}
	if r.ko.Spec.HealthCheckGracePeriod != nil {
		healthCheckGracePeriodCopy0 := *r.ko.Spec.HealthCheckGracePeriod
		if healthCheckGracePeriodCopy0 > math.MaxInt32 || healthCheckGracePeriodCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field HealthCheckGracePeriod is of type int32")
		}
		healthCheckGracePeriodCopy := int32(healthCheckGracePeriodCopy0)
		res.HealthCheckGracePeriod = &healthCheckGracePeriodCopy
	}
	if r.ko.Spec.HealthCheckType != nil {
		res.HealthCheckType = r.ko.Spec.HealthCheckType
	}
	if r.ko.Spec.InstanceID != nil {
		res.InstanceId = r.ko.Spec.InstanceID
	}
	if r.ko.Spec.InstanceLifecyclePolicy != nil {
		f14 := &svcsdktypes.InstanceLifecyclePolicy{}
		if r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers != nil {
			f14f0 := &svcsdktypes.RetentionTriggers{}
			if r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon != nil {
				f14f0.TerminateHookAbandon = svcsdktypes.RetentionAction(*r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon)
			}
			f14.RetentionTriggers = f14f0
		}
		res.InstanceLifecyclePolicy = f14
	}
	if r.ko.Spec.InstanceMaintenancePolicy != nil {
		f15 := &svcsdktypes.InstanceMaintenancePolicy{}
		if r.ko.Spec.InstanceMaintenancePolicy.MaxHealthyPercentage != nil {
			maxHealthyPercentageCopy0 := *r.ko.Spec.InstanceMaintenancePolicy.MaxHealthyPercentage
			if maxHealthyPercentageCopy0 > math.MaxInt32 || maxHealthyPercentageCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaxHealthyPercentage is of type int32")
			}
			maxHealthyPercentageCopy := int32(maxHealthyPercentageCopy0)
			f15.MaxHealthyPercentage = &maxHealthyPercentageCopy
		}
		if r.ko.Spec.InstanceMaintenancePolicy.MinHealthyPercentage != nil {
			minHealthyPercentageCopy0 := *r.ko.Spec.InstanceMaintenancePolicy.MinHealthyPercentage
			if minHealthyPercentageCopy0 > math.MaxInt32 || minHealthyPercentageCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MinHealthyPercentage is of type int32")
			}
			minHealthyPercentageCopy := int32(minHealthyPercentageCopy0)
			f15.MinHealthyPercentage = &minHealthyPercentageCopy
		}
		res.InstanceMaintenancePolicy = f15
	}
	if r.ko.Spec.LaunchConfigurationName != nil {
		res.LaunchConfigurationName = r.ko.Spec.LaunchConfigurationName
	}
	if r.ko.Spec.LaunchTemplate != nil {
		f17 := &svcsdktypes.LaunchTemplateSpecification{}
		if r.ko.Spec.LaunchTemplate.LaunchTemplateID != nil {
			f17.LaunchTemplateId = r.ko.Spec.LaunchTemplate.LaunchTemplateID
		}
		if r.ko.Spec.LaunchTemplate.LaunchTemplateName != nil {
			f17.LaunchTemplateName = r.ko.Spec.LaunchTemplate.LaunchTemplateName
		}
		if r.ko.Spec.LaunchTemplate.Version != nil {
			f17.Version = r.ko.Spec.LaunchTemplate.Version
		}
		res.LaunchTemplate = f17
	}
	if r.ko.Spec.LifecycleHookSpecificationList != nil {
		f18 := []svcsdktypes.LifecycleHookSpecification{}
		for _, f18iter := range r.ko.Spec.LifecycleHookSpecificationList {
			f18elem := &svcsdktypes.LifecycleHookSpecification{}
			if f18iter.DefaultResult != nil {
				f18elem.DefaultResult = f18iter.DefaultResult
			}
			if f18iter.HeartbeatTimeout != nil {
				heartbeatTimeoutCopy0 := *f18iter.HeartbeatTimeout
				if heartbeatTimeoutCopy0 > math.MaxInt32 || heartbeatTimeoutCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field HeartbeatTimeout is of type int32")
				}
				heartbeatTimeoutCopy := int32(heartbeatTimeoutCopy0)
				f18elem.HeartbeatTimeout = &heartbeatTimeoutCopy
			}
			if f18iter.LifecycleHookName != nil {
				f18elem.LifecycleHookName = f18iter.LifecycleHookName
			}
			if f18iter.LifecycleTransition != nil {
				f18elem.LifecycleTransition = f18iter.LifecycleTransition
			}
			if f18iter.NotificationMetadata != nil {
				f18elem.NotificationMetadata = f18iter.NotificationMetadata
			}
			if f18iter.NotificationTargetARN != nil {
				f18elem.NotificationTargetARN = f18iter.NotificationTargetARN
			}
			if f18iter.RoleARN != nil {
				f18elem.RoleARN = f18iter.RoleARN
			}
			f18 = append(f18, *f18elem)
		}
		res.LifecycleHookSpecificationList = f18
	}
	if r.ko.Spec.LoadBalancerNames != nil {
		res.LoadBalancerNames = aws.ToStringSlice(r.ko.Spec.LoadBalancerNames)
	}
	if r.ko.Spec.MaxInstanceLifetime != nil {
		maxInstanceLifetimeCopy0 := *r.ko.Spec.MaxInstanceLifetime
		if maxInstanceLifetimeCopy0 > math.MaxInt32 || maxInstanceLifetimeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MaxInstanceLifetime is of type int32")
		}
		maxInstanceLifetimeCopy := int32(maxInstanceLifetimeCopy0)
		res.MaxInstanceLifetime = &maxInstanceLifetimeCopy
	}
	if r.ko.Spec.MaxSize != nil {
		maxSizeCopy0 := *r.ko.Spec.MaxSize
		if maxSizeCopy0 > math.MaxInt32 || maxSizeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MaxSize is of type int32")
		}
		maxSizeCopy := int32(maxSizeCopy0)
		res.MaxSize = &maxSizeCopy
	}
	if r.ko.Spec.MinSize != nil {
		minSizeCopy0 := *r.ko.Spec.MinSize
		if minSizeCopy0 > math.MaxInt32 || minSizeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MinSize is of type int32")
		}
		minSizeCopy := int32(minSizeCopy0)
		res.MinSize = &minSizeCopy
	}
	if r.ko.Spec.MixedInstancesPolicy != nil {
		f23 := &svcsdktypes.MixedInstancesPolicy{}
		if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution != nil {
			f23f0 := &svcsdktypes.InstancesDistribution{}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy != nil {
				f23f0.OnDemandAllocationStrategy = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity != nil {
				onDemandBaseCapacityCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity
				if onDemandBaseCapacityCopy0 > math.MaxInt32 || onDemandBaseCapacityCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field OnDemandBaseCapacity is of type int32")
				}
				onDemandBaseCapacityCopy := int32(onDemandBaseCapacityCopy0)
				f23f0.OnDemandBaseCapacity = &onDemandBaseCapacityCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity != nil {
				onDemandPercentageAboveBaseCapacityCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity
				if onDemandPercentageAboveBaseCapacityCopy0 > math.MaxInt32 || onDemandPercentageAboveBaseCapacityCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field OnDemandPercentageAboveBaseCapacity is of type int32")
				}
				onDemandPercentageAboveBaseCapacityCopy := int32(onDemandPercentageAboveBaseCapacityCopy0)
				f23f0.OnDemandPercentageAboveBaseCapacity = &onDemandPercentageAboveBaseCapacityCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy != nil {
				f23f0.SpotAllocationStrategy = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools != nil {
				spotInstancePoolsCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools
				if spotInstancePoolsCopy0 > math.MaxInt32 || spotInstancePoolsCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field SpotInstancePools is of type int32")
				}
				spotInstancePoolsCopy := int32(spotInstancePoolsCopy0)
				f23f0.SpotInstancePools = &spotInstancePoolsCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice != nil {
				f23f0.SpotMaxPrice = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice
			}
			f23.InstancesDistribution = f23f0
		}
		if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate != nil {
			f23f1 := &svcsdktypes.LaunchTemplate{}
			if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification != nil {
				f23f1f0 := &svcsdktypes.LaunchTemplateSpecification{}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateID != nil {
					f23f1f0.LaunchTemplateId = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateID
				}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName != nil {
					f23f1f0.LaunchTemplateName = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName
				}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version != nil {
					f23f1f0.Version = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version
				}
				f23f1.LaunchTemplateSpecification = f23f1f0
			}
			if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.Overrides != nil {
				f23f1f1 := []svcsdktypes.LaunchTemplateOverrides{}
				for _, f23f1f1iter := range r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.Overrides {
					f23f1f1elem := &svcsdktypes.LaunchTemplateOverrides{}
					if f23f1f1iter.ImageID != nil {
						f23f1f1elem.ImageId = f23f1f1iter.ImageID
					}
					if f23f1f1iter.InstanceRequirements != nil {
						f23f1f1elemf1 := &svcsdktypes.InstanceRequirements{}
						if f23f1f1iter.InstanceRequirements.AcceleratorCount != nil {
							f23f1f1elemf1f0 := &svcsdktypes.AcceleratorCountRequest{}
							if f23f1f1iter.InstanceRequirements.AcceleratorCount.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.AcceleratorCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f0.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.AcceleratorCount.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.AcceleratorCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f0.Min = &minCopy
							}
							f23f1f1elemf1.AcceleratorCount = f23f1f1elemf1f0
						}
						if f23f1f1iter.InstanceRequirements.AcceleratorManufacturers != nil {
							f23f1f1elemf1f1 := []svcsdktypes.AcceleratorManufacturer{}
							for _, f23f1f1elemf1f1iter := range f23f1f1iter.InstanceRequirements.AcceleratorManufacturers {
								var f23f1f1elemf1f1elem string
								f23f1f1elemf1f1elem = string(*f23f1f1elemf1f1iter)
								f23f1f1elemf1f1 = append(f23f1f1elemf1f1, svcsdktypes.AcceleratorManufacturer(f23f1f1elemf1f1elem))
							}
							f23f1f1elemf1.AcceleratorManufacturers = f23f1f1elemf1f1
						}
						if f23f1f1iter.InstanceRequirements.AcceleratorNames != nil {
							f23f1f1elemf1f2 := []svcsdktypes.AcceleratorName{}
							for _, f23f1f1elemf1f2iter := range f23f1f1iter.InstanceRequirements.AcceleratorNames {
								var f23f1f1elemf1f2elem string
								f23f1f1elemf1f2elem = string(*f23f1f1elemf1f2iter)
								f23f1f1elemf1f2 = append(f23f1f1elemf1f2, svcsdktypes.AcceleratorName(f23f1f1elemf1f2elem))
							}
							f23f1f1elemf1.AcceleratorNames = f23f1f1elemf1f2
						}
						if f23f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB != nil {
							f23f1f1elemf1f3 := &svcsdktypes.AcceleratorTotalMemoryMiBRequest{}
							if f23f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f3.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f3.Min = &minCopy
							}
							f23f1f1elemf1.AcceleratorTotalMemoryMiB = f23f1f1elemf1f3
						}
						if f23f1f1iter.InstanceRequirements.AcceleratorTypes != nil {
							f23f1f1elemf1f4 := []svcsdktypes.AcceleratorType{}
							for _, f23f1f1elemf1f4iter := range f23f1f1iter.InstanceRequirements.AcceleratorTypes {
								var f23f1f1elemf1f4elem string
								f23f1f1elemf1f4elem = string(*f23f1f1elemf1f4iter)
								f23f1f1elemf1f4 = append(f23f1f1elemf1f4, svcsdktypes.AcceleratorType(f23f1f1elemf1f4elem))
							}
							f23f1f1elemf1.AcceleratorTypes = f23f1f1elemf1f4
						}
						if f23f1f1iter.InstanceRequirements.AllowedInstanceTypes != nil {
							f23f1f1elemf1.AllowedInstanceTypes = aws.ToStringSlice(f23f1f1iter.InstanceRequirements.AllowedInstanceTypes)
						}
						if f23f1f1iter.InstanceRequirements.BareMetal != nil {
							f23f1f1elemf1.BareMetal = svcsdktypes.BareMetal(*f23f1f1iter.InstanceRequirements.BareMetal)
						}
						if f23f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps != nil {
							f23f1f1elemf1f7 := &svcsdktypes.BaselineEbsBandwidthMbpsRequest{}
							if f23f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f7.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f7.Min = &minCopy
							}
							f23f1f1elemf1.BaselineEbsBandwidthMbps = f23f1f1elemf1f7
						}
						if f23f1f1iter.InstanceRequirements.BaselinePerformanceFactors != nil {
							f23f1f1elemf1f8 := &svcsdktypes.BaselinePerformanceFactorsRequest{}
							if f23f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU != nil {
								f23f1f1elemf1f8f0 := &svcsdktypes.CpuPerformanceFactorRequest{}
								if f23f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU.References != nil {
									f23f1f1elemf1f8f0f0 := []svcsdktypes.PerformanceFactorReferenceRequest{}
									for _, f23f1f1elemf1f8f0f0iter := range f23f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU.References {
										f23f1f1elemf1f8f0f0elem := &svcsdktypes.PerformanceFactorReferenceRequest{}
										if f23f1f1elemf1f8f0f0iter.InstanceFamily != nil {
											f23f1f1elemf1f8f0f0elem.InstanceFamily = f23f1f1elemf1f8f0f0iter.InstanceFamily
										}
										f23f1f1elemf1f8f0f0 = append(f23f1f1elemf1f8f0f0, *f23f1f1elemf1f8f0f0elem)
									}
									f23f1f1elemf1f8f0.References = f23f1f1elemf1f8f0f0
								}
								f23f1f1elemf1f8.Cpu = f23f1f1elemf1f8f0
							}
							f23f1f1elemf1.BaselinePerformanceFactors = f23f1f1elemf1f8
						}
						if f23f1f1iter.InstanceRequirements.BurstablePerformance != nil {
							f23f1f1elemf1.BurstablePerformance = svcsdktypes.BurstablePerformance(*f23f1f1iter.InstanceRequirements.BurstablePerformance)
						}
						if f23f1f1iter.InstanceRequirements.CPUManufacturers != nil {
							f23f1f1elemf1f10 := []svcsdktypes.CpuManufacturer{}
							for _, f23f1f1elemf1f10iter := range f23f1f1iter.InstanceRequirements.CPUManufacturers {
								var f23f1f1elemf1f10elem string
								f23f1f1elemf1f10elem = string(*f23f1f1elemf1f10iter)
								f23f1f1elemf1f10 = append(f23f1f1elemf1f10, svcsdktypes.CpuManufacturer(f23f1f1elemf1f10elem))
							}
							f23f1f1elemf1.CpuManufacturers = f23f1f1elemf1f10
						}
						if f23f1f1iter.InstanceRequirements.ExcludedInstanceTypes != nil {
							f23f1f1elemf1.ExcludedInstanceTypes = aws.ToStringSlice(f23f1f1iter.InstanceRequirements.ExcludedInstanceTypes)
						}
						if f23f1f1iter.InstanceRequirements.InstanceGenerations != nil {
							f23f1f1elemf1f12 := []svcsdktypes.InstanceGeneration{}
							for _, f23f1f1elemf1f12iter := range f23f1f1iter.InstanceRequirements.InstanceGenerations {
								var f23f1f1elemf1f12elem string
								f23f1f1elemf1f12elem = string(*f23f1f1elemf1f12iter)
								f23f1f1elemf1f12 = append(f23f1f1elemf1f12, svcsdktypes.InstanceGeneration(f23f1f1elemf1f12elem))
							}
							f23f1f1elemf1.InstanceGenerations = f23f1f1elemf1f12
						}
						if f23f1f1iter.InstanceRequirements.LocalStorage != nil {
							f23f1f1elemf1.LocalStorage = svcsdktypes.LocalStorage(*f23f1f1iter.InstanceRequirements.LocalStorage)
						}
						if f23f1f1iter.InstanceRequirements.LocalStorageTypes != nil {
							f23f1f1elemf1f14 := []svcsdktypes.LocalStorageType{}
							for _, f23f1f1elemf1f14iter := range f23f1f1iter.InstanceRequirements.LocalStorageTypes {
								var f23f1f1elemf1f14elem string
								f23f1f1elemf1f14elem = string(*f23f1f1elemf1f14iter)
								f23f1f1elemf1f14 = append(f23f1f1elemf1f14, svcsdktypes.LocalStorageType(f23f1f1elemf1f14elem))
							}
							f23f1f1elemf1.LocalStorageTypes = f23f1f1elemf1f14
						}
						if f23f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice != nil {
							maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 := *f23f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice
							if maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 > math.MaxInt32 || maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field MaxSpotPriceAsPercentageOfOptimalOnDemandPrice is of type int32")
							}
							maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy := int32(maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0)
							f23f1f1elemf1.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice = &maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy
						}
						if f23f1f1iter.InstanceRequirements.MemoryGiBPerVCPU != nil {
							f23f1f1elemf1f16 := &svcsdktypes.MemoryGiBPerVCpuRequest{}
							if f23f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Max != nil {
								f23f1f1elemf1f16.Max = f23f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Max
							}
							if f23f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Min != nil {
								f23f1f1elemf1f16.Min = f23f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Min
							}
							f23f1f1elemf1.MemoryGiBPerVCpu = f23f1f1elemf1f16
						}
						if f23f1f1iter.InstanceRequirements.MemoryMiB != nil {
							f23f1f1elemf1f17 := &svcsdktypes.MemoryMiBRequest{}
							if f23f1f1iter.InstanceRequirements.MemoryMiB.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.MemoryMiB.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f17.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.MemoryMiB.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.MemoryMiB.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f17.Min = &minCopy
							}
							f23f1f1elemf1.MemoryMiB = f23f1f1elemf1f17
						}
						if f23f1f1iter.InstanceRequirements.NetworkBandwidthGbps != nil {
							f23f1f1elemf1f18 := &svcsdktypes.NetworkBandwidthGbpsRequest{}
							if f23f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max != nil {
								f23f1f1elemf1f18.Max = f23f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max
							}
							if f23f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min != nil {
								f23f1f1elemf1f18.Min = f23f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min
							}
							f23f1f1elemf1.NetworkBandwidthGbps = f23f1f1elemf1f18
						}
						if f23f1f1iter.InstanceRequirements.NetworkInterfaceCount != nil {
							f23f1f1elemf1f19 := &svcsdktypes.NetworkInterfaceCountRequest{}
							if f23f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f19.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f19.Min = &minCopy
							}
							f23f1f1elemf1.NetworkInterfaceCount = f23f1f1elemf1f19
						}
						if f23f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice != nil {
							onDemandMaxPricePercentageOverLowestPriceCopy0 := *f23f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice
							if onDemandMaxPricePercentageOverLowestPriceCopy0 > math.MaxInt32 || onDemandMaxPricePercentageOverLowestPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field OnDemandMaxPricePercentageOverLowestPrice is of type int32")
							}
							onDemandMaxPricePercentageOverLowestPriceCopy := int32(onDemandMaxPricePercentageOverLowestPriceCopy0)
							f23f1f1elemf1.OnDemandMaxPricePercentageOverLowestPrice = &onDemandMaxPricePercentageOverLowestPriceCopy
						}
						if f23f1f1iter.InstanceRequirements.RequireHibernateSupport != nil {
							f23f1f1elemf1.RequireHibernateSupport = f23f1f1iter.InstanceRequirements.RequireHibernateSupport
						}
						if f23f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice != nil {
							spotMaxPricePercentageOverLowestPriceCopy0 := *f23f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice
							if spotMaxPricePercentageOverLowestPriceCopy0 > math.MaxInt32 || spotMaxPricePercentageOverLowestPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field SpotMaxPricePercentageOverLowestPrice is of type int32")
							}
							spotMaxPricePercentageOverLowestPriceCopy := int32(spotMaxPricePercentageOverLowestPriceCopy0)
							f23f1f1elemf1.SpotMaxPricePercentageOverLowestPrice = &spotMaxPricePercentageOverLowestPriceCopy
						}
						if f23f1f1iter.InstanceRequirements.TotalLocalStorageGB != nil {
							f23f1f1elemf1f23 := &svcsdktypes.TotalLocalStorageGBRequest{}
							if f23f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max != nil {
								f23f1f1elemf1f23.Max = f23f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max
							}
							if f23f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min != nil {
								f23f1f1elemf1f23.Min = f23f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min
							}
							f23f1f1elemf1.TotalLocalStorageGB = f23f1f1elemf1f23
						}
						if f23f1f1iter.InstanceRequirements.VCPUCount != nil {
							f23f1f1elemf1f24 := &svcsdktypes.VCpuCountRequest{}
							if f23f1f1iter.InstanceRequirements.VCPUCount.Max != nil {
								maxCopy0 := *f23f1f1iter.InstanceRequirements.VCPUCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f23f1f1elemf1f24.Max = &maxCopy
							}
							if f23f1f1iter.InstanceRequirements.VCPUCount.Min != nil {
								minCopy0 := *f23f1f1iter.InstanceRequirements.VCPUCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f23f1f1elemf1f24.Min = &minCopy
							}
							f23f1f1elemf1.VCpuCount = f23f1f1elemf1f24
						}
						f23f1f1elem.InstanceRequirements = f23f1f1elemf1
					}
					if f23f1f1iter.InstanceType != nil {
						f23f1f1elem.InstanceType = f23f1f1iter.InstanceType
					}
					if f23f1f1iter.LaunchTemplateSpecification != nil {
						f23f1f1elemf3 := &svcsdktypes.LaunchTemplateSpecification{}
						if f23f1f1iter.LaunchTemplateSpecification.LaunchTemplateID != nil {
							f23f1f1elemf3.LaunchTemplateId = f23f1f1iter.LaunchTemplateSpecification.LaunchTemplateID
						}
						if f23f1f1iter.LaunchTemplateSpecification.LaunchTemplateName != nil {
							f23f1f1elemf3.LaunchTemplateName = f23f1f1iter.LaunchTemplateSpecification.LaunchTemplateName
						}
						if f23f1f1iter.LaunchTemplateSpecification.Version != nil {
							f23f1f1elemf3.Version = f23f1f1iter.LaunchTemplateSpecification.Version
						}
						f23f1f1elem.LaunchTemplateSpecification = f23f1f1elemf3
					}
					if f23f1f1iter.WeightedCapacity != nil {
						f23f1f1elem.WeightedCapacity = f23f1f1iter.WeightedCapacity
					}
					f23f1f1 = append(f23f1f1, *f23f1f1elem)
				}
				f23f1.Overrides = f23f1f1
			}
			f23.LaunchTemplate = f23f1
		}
		res.MixedInstancesPolicy = f23
	}
	if r.ko.Spec.NewInstancesProtectedFromScaleIn != nil {
		res.NewInstancesProtectedFromScaleIn = r.ko.Spec.NewInstancesProtectedFromScaleIn
	}
	if r.ko.Spec.PlacementGroup != nil {
		res.PlacementGroup = r.ko.Spec.PlacementGroup
	}
	if r.ko.Spec.ServiceLinkedRoleARN != nil {
		res.ServiceLinkedRoleARN = r.ko.Spec.ServiceLinkedRoleARN
	}
	if r.ko.Spec.SkipZonalShiftValidation != nil {
		res.SkipZonalShiftValidation = r.ko.Spec.SkipZonalShiftValidation
	}
	if r.ko.Spec.Tags != nil {
		f28 := []svcsdktypes.Tag{}
		for _, f28iter := range r.ko.Spec.Tags {
			f28elem := &svcsdktypes.Tag{}
			if f28iter.Key != nil {
				f28elem.Key = f28iter.Key
			}
			if f28iter.PropagateAtLaunch != nil {
				f28elem.PropagateAtLaunch = f28iter.PropagateAtLaunch
			}
			if f28iter.ResourceID != nil {
				f28elem.ResourceId = f28iter.ResourceID
			}
			if f28iter.ResourceType != nil {
				f28elem.ResourceType = f28iter.ResourceType
			}
			if f28iter.Value != nil {
				f28elem.Value = f28iter.Value
			}
			f28 = append(f28, *f28elem)
		}
		res.Tags = f28
	}
	if r.ko.Spec.TargetGroupARNs != nil {
		res.TargetGroupARNs = aws.ToStringSlice(r.ko.Spec.TargetGroupARNs)
	}
	if r.ko.Spec.TerminationPolicies != nil {
		res.TerminationPolicies = aws.ToStringSlice(r.ko.Spec.TerminationPolicies)
	}
	if r.ko.Spec.TrafficSources != nil {
		f31 := []svcsdktypes.TrafficSourceIdentifier{}
		for _, f31iter := range r.ko.Spec.TrafficSources {
			f31elem := &svcsdktypes.TrafficSourceIdentifier{}
			if f31iter.Identifier != nil {
				f31elem.Identifier = f31iter.Identifier
			}
			if f31iter.Type != nil {
				f31elem.Type = f31iter.Type
			}
			f31 = append(f31, *f31elem)
		}
		res.TrafficSources = f31
	}
	if r.ko.Spec.VPCZoneIdentifier != nil {
		res.VPCZoneIdentifier = r.ko.Spec.VPCZoneIdentifier
	}

	return res, nil
}

// sdkUpdate patches the supplied resource in the backend AWS service API and
// returns a new resource with updated fields.
func (rm *resourceManager) sdkUpdate(
	ctx context.Context,
	desired *resource,
	latest *resource,
	delta *ackcompare.Delta,
) (updated *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkUpdate")
	defer func() {
		exit(err)
	}()
	if delta.DifferentAt("Spec.Tags") {
		err := rm.syncTags(
			ctx,
			latest,
			desired,
		)
		if err != nil {
			return nil, err
		}
	}
	if !delta.DifferentExcept("Spec.Tags") {
		return desired, nil
	}

	input, err := rm.newUpdateRequestPayload(ctx, desired, delta)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.UpdateAutoScalingGroupOutput
	_ = resp
	resp, err = rm.sdkapi.UpdateAutoScalingGroup(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "UpdateAutoScalingGroup", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// newUpdateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Update API call for the resource
func (rm *resourceManager) newUpdateRequestPayload(
	ctx context.Context,
	r *resource,
	delta *ackcompare.Delta,
) (*svcsdk.UpdateAutoScalingGroupInput, error) {
	res := &svcsdk.UpdateAutoScalingGroupInput{}

	if r.ko.Spec.AutoScalingGroupName != nil {
		res.AutoScalingGroupName = r.ko.Spec.AutoScalingGroupName
	}
	if r.ko.Spec.AvailabilityZoneDistribution != nil {
		f1 := &svcsdktypes.AvailabilityZoneDistribution{}
		if r.ko.Spec.AvailabilityZoneDistribution.CapacityDistributionStrategy != nil {
			f1.CapacityDistributionStrategy = svcsdktypes.CapacityDistributionStrategy(*r.ko.Spec.AvailabilityZoneDistribution.CapacityDistributionStrategy)
		}
		res.AvailabilityZoneDistribution = f1
	}
	if r.ko.Spec.AvailabilityZoneImpairmentPolicy != nil {
		f2 := &svcsdktypes.AvailabilityZoneImpairmentPolicy{}
		if r.ko.Spec.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior != nil {
			f2.ImpairedZoneHealthCheckBehavior = svcsdktypes.ImpairedZoneHealthCheckBehavior(*r.ko.Spec.AvailabilityZoneImpairmentPolicy.ImpairedZoneHealthCheckBehavior)
		}
		if r.ko.Spec.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled != nil {
			f2.ZonalShiftEnabled = r.ko.Spec.AvailabilityZoneImpairmentPolicy.ZonalShiftEnabled
		}
		res.AvailabilityZoneImpairmentPolicy = f2
	}
	if r.ko.Spec.AvailabilityZones != nil {
		res.AvailabilityZones = aws.ToStringSlice(r.ko.Spec.AvailabilityZones)
	}
	if r.ko.Spec.CapacityRebalance != nil {
		res.CapacityRebalance = r.ko.Spec.CapacityRebalance
	}
	if r.ko.Spec.CapacityReservationSpecification != nil {
		f5 := &svcsdktypes.CapacityReservationSpecification{}
		if r.ko.Spec.CapacityReservationSpecification.CapacityReservationPreference != nil {
			f5.CapacityReservationPreference = svcsdktypes.CapacityReservationPreference(*r.ko.Spec.CapacityReservationSpecification.CapacityReservationPreference)
		}
		if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget != nil {
			f5f1 := &svcsdktypes.CapacityReservationTarget{}
			if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIDs != nil {
				f5f1.CapacityReservationIds = aws.ToStringSlice(r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationIDs)
			}
			if r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupARNs != nil {
				f5f1.CapacityReservationResourceGroupArns = aws.ToStringSlice(r.ko.Spec.CapacityReservationSpecification.CapacityReservationTarget.CapacityReservationResourceGroupARNs)
			}
			f5.CapacityReservationTarget = f5f1
		}
		res.CapacityReservationSpecification = f5
	}
	if r.ko.Spec.Context != nil {
		res.Context = r.ko.Spec.Context
	}
	if r.ko.Spec.DefaultCooldown != nil {
		defaultCooldownCopy0 := *r.ko.Spec.DefaultCooldown
		if defaultCooldownCopy0 > math.MaxInt32 || defaultCooldownCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DefaultCooldown is of type int32")
		}
		defaultCooldownCopy := int32(defaultCooldownCopy0)
		res.DefaultCooldown = &defaultCooldownCopy
	}
	if r.ko.Spec.DefaultInstanceWarmup != nil {
		defaultInstanceWarmupCopy0 := *r.ko.Spec.DefaultInstanceWarmup
		if defaultInstanceWarmupCopy0 > math.MaxInt32 || defaultInstanceWarmupCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DefaultInstanceWarmup is of type int32")
		}
		defaultInstanceWarmupCopy := int32(defaultInstanceWarmupCopy0)
		res.DefaultInstanceWarmup = &defaultInstanceWarmupCopy
	}
	if r.ko.Spec.DesiredCapacity != nil {
		desiredCapacityCopy0 := *r.ko.Spec.DesiredCapacity
		if desiredCapacityCopy0 > math.MaxInt32 || desiredCapacityCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field DesiredCapacity is of type int32")
		}
		desiredCapacityCopy := int32(desiredCapacityCopy0)
		res.DesiredCapacity = &desiredCapacityCopy
	}
	if r.ko.Spec.DesiredCapacityType != nil {
		res.DesiredCapacityType = r.ko.Spec.DesiredCapacityType
	}
	if r.ko.Spec.HealthCheckGracePeriod != nil {
		healthCheckGracePeriodCopy0 := *r.ko.Spec.HealthCheckGracePeriod
		if healthCheckGracePeriodCopy0 > math.MaxInt32 || healthCheckGracePeriodCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field HealthCheckGracePeriod is of type int32")
		}
		healthCheckGracePeriodCopy := int32(healthCheckGracePeriodCopy0)
		res.HealthCheckGracePeriod = &healthCheckGracePeriodCopy
	}
	if r.ko.Spec.HealthCheckType != nil {
		res.HealthCheckType = r.ko.Spec.HealthCheckType
	}
	if r.ko.Spec.InstanceLifecyclePolicy != nil {
		f13 := &svcsdktypes.InstanceLifecyclePolicy{}
		if r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers != nil {
			f13f0 := &svcsdktypes.RetentionTriggers{}
			if r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon != nil {
				f13f0.TerminateHookAbandon = svcsdktypes.RetentionAction(*r.ko.Spec.InstanceLifecyclePolicy.RetentionTriggers.TerminateHookAbandon)
			}
			f13.RetentionTriggers = f13f0
		}
		res.InstanceLifecyclePolicy = f13
	}
	if r.ko.Spec.InstanceMaintenancePolicy != nil {
		f14 := &svcsdktypes.InstanceMaintenancePolicy{}
		if r.ko.Spec.InstanceMaintenancePolicy.MaxHealthyPercentage != nil {
			maxHealthyPercentageCopy0 := *r.ko.Spec.InstanceMaintenancePolicy.MaxHealthyPercentage
			if maxHealthyPercentageCopy0 > math.MaxInt32 || maxHealthyPercentageCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaxHealthyPercentage is of type int32")
			}
			maxHealthyPercentageCopy := int32(maxHealthyPercentageCopy0)
			f14.MaxHealthyPercentage = &maxHealthyPercentageCopy
		}
		if r.ko.Spec.InstanceMaintenancePolicy.MinHealthyPercentage != nil {
			minHealthyPercentageCopy0 := *r.ko.Spec.InstanceMaintenancePolicy.MinHealthyPercentage
			if minHealthyPercentageCopy0 > math.MaxInt32 || minHealthyPercentageCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MinHealthyPercentage is of type int32")
			}
			minHealthyPercentageCopy := int32(minHealthyPercentageCopy0)
			f14.MinHealthyPercentage = &minHealthyPercentageCopy
		}
		res.InstanceMaintenancePolicy = f14
	}
	if r.ko.Spec.LaunchConfigurationName != nil {
		res.LaunchConfigurationName = r.ko.Spec.LaunchConfigurationName
	}
	if r.ko.Spec.LaunchTemplate != nil {
		f16 := &svcsdktypes.LaunchTemplateSpecification{}
		if r.ko.Spec.LaunchTemplate.LaunchTemplateID != nil {
			f16.LaunchTemplateId = r.ko.Spec.LaunchTemplate.LaunchTemplateID
		}
		if r.ko.Spec.LaunchTemplate.LaunchTemplateName != nil {
			f16.LaunchTemplateName = r.ko.Spec.LaunchTemplate.LaunchTemplateName
		}
		if r.ko.Spec.LaunchTemplate.Version != nil {
			f16.Version = r.ko.Spec.LaunchTemplate.Version
		}
		res.LaunchTemplate = f16
	}
	if r.ko.Spec.MaxInstanceLifetime != nil {
		maxInstanceLifetimeCopy0 := *r.ko.Spec.MaxInstanceLifetime
		if maxInstanceLifetimeCopy0 > math.MaxInt32 || maxInstanceLifetimeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MaxInstanceLifetime is of type int32")
		}
		maxInstanceLifetimeCopy := int32(maxInstanceLifetimeCopy0)
		res.MaxInstanceLifetime = &maxInstanceLifetimeCopy
	}
	if r.ko.Spec.MaxSize != nil {
		maxSizeCopy0 := *r.ko.Spec.MaxSize
		if maxSizeCopy0 > math.MaxInt32 || maxSizeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MaxSize is of type int32")
		}
		maxSizeCopy := int32(maxSizeCopy0)
		res.MaxSize = &maxSizeCopy
	}
	if r.ko.Spec.MinSize != nil {
		minSizeCopy0 := *r.ko.Spec.MinSize
		if minSizeCopy0 > math.MaxInt32 || minSizeCopy0 < math.MinInt32 {
			return nil, fmt.Errorf("error: field MinSize is of type int32")
		}
		minSizeCopy := int32(minSizeCopy0)
		res.MinSize = &minSizeCopy
	}
	if r.ko.Spec.MixedInstancesPolicy != nil {
		f20 := &svcsdktypes.MixedInstancesPolicy{}
		if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution != nil {
			f20f0 := &svcsdktypes.InstancesDistribution{}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy != nil {
				f20f0.OnDemandAllocationStrategy = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity != nil {
				onDemandBaseCapacityCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity
				if onDemandBaseCapacityCopy0 > math.MaxInt32 || onDemandBaseCapacityCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field OnDemandBaseCapacity is of type int32")
				}
				onDemandBaseCapacityCopy := int32(onDemandBaseCapacityCopy0)
				f20f0.OnDemandBaseCapacity = &onDemandBaseCapacityCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity != nil {
				onDemandPercentageAboveBaseCapacityCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity
				if onDemandPercentageAboveBaseCapacityCopy0 > math.MaxInt32 || onDemandPercentageAboveBaseCapacityCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field OnDemandPercentageAboveBaseCapacity is of type int32")
				}
				onDemandPercentageAboveBaseCapacityCopy := int32(onDemandPercentageAboveBaseCapacityCopy0)
				f20f0.OnDemandPercentageAboveBaseCapacity = &onDemandPercentageAboveBaseCapacityCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy != nil {
				f20f0.SpotAllocationStrategy = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools != nil {
				spotInstancePoolsCopy0 := *r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools
				if spotInstancePoolsCopy0 > math.MaxInt32 || spotInstancePoolsCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field SpotInstancePools is of type int32")
				}
				spotInstancePoolsCopy := int32(spotInstancePoolsCopy0)
				f20f0.SpotInstancePools = &spotInstancePoolsCopy
			}
			if r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice != nil {
				f20f0.SpotMaxPrice = r.ko.Spec.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice
			}
			f20.InstancesDistribution = f20f0
		}
		if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate != nil {
			f20f1 := &svcsdktypes.LaunchTemplate{}
			if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification != nil {
				f20f1f0 := &svcsdktypes.LaunchTemplateSpecification{}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateID != nil {
					f20f1f0.LaunchTemplateId = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateID
				}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName != nil {
					f20f1f0.LaunchTemplateName = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName
				}
				if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version != nil {
					f20f1f0.Version = r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version
				}
				f20f1.LaunchTemplateSpecification = f20f1f0
			}
			if r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.Overrides != nil {
				f20f1f1 := []svcsdktypes.LaunchTemplateOverrides{}
				for _, f20f1f1iter := range r.ko.Spec.MixedInstancesPolicy.LaunchTemplate.Overrides {
					f20f1f1elem := &svcsdktypes.LaunchTemplateOverrides{}
					if f20f1f1iter.ImageID != nil {
						f20f1f1elem.ImageId = f20f1f1iter.ImageID
					}
					if f20f1f1iter.InstanceRequirements != nil {
						f20f1f1elemf1 := &svcsdktypes.InstanceRequirements{}
						if f20f1f1iter.InstanceRequirements.AcceleratorCount != nil {
							f20f1f1elemf1f0 := &svcsdktypes.AcceleratorCountRequest{}
							if f20f1f1iter.InstanceRequirements.AcceleratorCount.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.AcceleratorCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f0.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.AcceleratorCount.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.AcceleratorCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f0.Min = &minCopy
							}
							f20f1f1elemf1.AcceleratorCount = f20f1f1elemf1f0
						}
						if f20f1f1iter.InstanceRequirements.AcceleratorManufacturers != nil {
							f20f1f1elemf1f1 := []svcsdktypes.AcceleratorManufacturer{}
							for _, f20f1f1elemf1f1iter := range f20f1f1iter.InstanceRequirements.AcceleratorManufacturers {
								var f20f1f1elemf1f1elem string
								f20f1f1elemf1f1elem = string(*f20f1f1elemf1f1iter)
								f20f1f1elemf1f1 = append(f20f1f1elemf1f1, svcsdktypes.AcceleratorManufacturer(f20f1f1elemf1f1elem))
							}
							f20f1f1elemf1.AcceleratorManufacturers = f20f1f1elemf1f1
						}
						if f20f1f1iter.InstanceRequirements.AcceleratorNames != nil {
							f20f1f1elemf1f2 := []svcsdktypes.AcceleratorName{}
							for _, f20f1f1elemf1f2iter := range f20f1f1iter.InstanceRequirements.AcceleratorNames {
								var f20f1f1elemf1f2elem string
								f20f1f1elemf1f2elem = string(*f20f1f1elemf1f2iter)
								f20f1f1elemf1f2 = append(f20f1f1elemf1f2, svcsdktypes.AcceleratorName(f20f1f1elemf1f2elem))
							}
							f20f1f1elemf1.AcceleratorNames = f20f1f1elemf1f2
						}
						if f20f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB != nil {
							f20f1f1elemf1f3 := &svcsdktypes.AcceleratorTotalMemoryMiBRequest{}
							if f20f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f3.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.AcceleratorTotalMemoryMiB.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f3.Min = &minCopy
							}
							f20f1f1elemf1.AcceleratorTotalMemoryMiB = f20f1f1elemf1f3
						}
						if f20f1f1iter.InstanceRequirements.AcceleratorTypes != nil {
							f20f1f1elemf1f4 := []svcsdktypes.AcceleratorType{}
							for _, f20f1f1elemf1f4iter := range f20f1f1iter.InstanceRequirements.AcceleratorTypes {
								var f20f1f1elemf1f4elem string
								f20f1f1elemf1f4elem = string(*f20f1f1elemf1f4iter)
								f20f1f1elemf1f4 = append(f20f1f1elemf1f4, svcsdktypes.AcceleratorType(f20f1f1elemf1f4elem))
							}
							f20f1f1elemf1.AcceleratorTypes = f20f1f1elemf1f4
						}
						if f20f1f1iter.InstanceRequirements.AllowedInstanceTypes != nil {
							f20f1f1elemf1.AllowedInstanceTypes = aws.ToStringSlice(f20f1f1iter.InstanceRequirements.AllowedInstanceTypes)
						}
						if f20f1f1iter.InstanceRequirements.BareMetal != nil {
							f20f1f1elemf1.BareMetal = svcsdktypes.BareMetal(*f20f1f1iter.InstanceRequirements.BareMetal)
						}
						if f20f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps != nil {
							f20f1f1elemf1f7 := &svcsdktypes.BaselineEbsBandwidthMbpsRequest{}
							if f20f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f7.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.BaselineEBSBandwidthMbps.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f7.Min = &minCopy
							}
							f20f1f1elemf1.BaselineEbsBandwidthMbps = f20f1f1elemf1f7
						}
						if f20f1f1iter.InstanceRequirements.BaselinePerformanceFactors != nil {
							f20f1f1elemf1f8 := &svcsdktypes.BaselinePerformanceFactorsRequest{}
							if f20f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU != nil {
								f20f1f1elemf1f8f0 := &svcsdktypes.CpuPerformanceFactorRequest{}
								if f20f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU.References != nil {
									f20f1f1elemf1f8f0f0 := []svcsdktypes.PerformanceFactorReferenceRequest{}
									for _, f20f1f1elemf1f8f0f0iter := range f20f1f1iter.InstanceRequirements.BaselinePerformanceFactors.CPU.References {
										f20f1f1elemf1f8f0f0elem := &svcsdktypes.PerformanceFactorReferenceRequest{}
										if f20f1f1elemf1f8f0f0iter.InstanceFamily != nil {
											f20f1f1elemf1f8f0f0elem.InstanceFamily = f20f1f1elemf1f8f0f0iter.InstanceFamily
										}
										f20f1f1elemf1f8f0f0 = append(f20f1f1elemf1f8f0f0, *f20f1f1elemf1f8f0f0elem)
									}
									f20f1f1elemf1f8f0.References = f20f1f1elemf1f8f0f0
								}
								f20f1f1elemf1f8.Cpu = f20f1f1elemf1f8f0
							}
							f20f1f1elemf1.BaselinePerformanceFactors = f20f1f1elemf1f8
						}
						if f20f1f1iter.InstanceRequirements.BurstablePerformance != nil {
							f20f1f1elemf1.BurstablePerformance = svcsdktypes.BurstablePerformance(*f20f1f1iter.InstanceRequirements.BurstablePerformance)
						}
						if f20f1f1iter.InstanceRequirements.CPUManufacturers != nil {
							f20f1f1elemf1f10 := []svcsdktypes.CpuManufacturer{}
							for _, f20f1f1elemf1f10iter := range f20f1f1iter.InstanceRequirements.CPUManufacturers {
								var f20f1f1elemf1f10elem string
								f20f1f1elemf1f10elem = string(*f20f1f1elemf1f10iter)
								f20f1f1elemf1f10 = append(f20f1f1elemf1f10, svcsdktypes.CpuManufacturer(f20f1f1elemf1f10elem))
							}
							f20f1f1elemf1.CpuManufacturers = f20f1f1elemf1f10
						}
						if f20f1f1iter.InstanceRequirements.ExcludedInstanceTypes != nil {
							f20f1f1elemf1.ExcludedInstanceTypes = aws.ToStringSlice(f20f1f1iter.InstanceRequirements.ExcludedInstanceTypes)
						}
						if f20f1f1iter.InstanceRequirements.InstanceGenerations != nil {
							f20f1f1elemf1f12 := []svcsdktypes.InstanceGeneration{}
							for _, f20f1f1elemf1f12iter := range f20f1f1iter.InstanceRequirements.InstanceGenerations {
								var f20f1f1elemf1f12elem string
								f20f1f1elemf1f12elem = string(*f20f1f1elemf1f12iter)
								f20f1f1elemf1f12 = append(f20f1f1elemf1f12, svcsdktypes.InstanceGeneration(f20f1f1elemf1f12elem))
							}
							f20f1f1elemf1.InstanceGenerations = f20f1f1elemf1f12
						}
						if f20f1f1iter.InstanceRequirements.LocalStorage != nil {
							f20f1f1elemf1.LocalStorage = svcsdktypes.LocalStorage(*f20f1f1iter.InstanceRequirements.LocalStorage)
						}
						if f20f1f1iter.InstanceRequirements.LocalStorageTypes != nil {
							f20f1f1elemf1f14 := []svcsdktypes.LocalStorageType{}
							for _, f20f1f1elemf1f14iter := range f20f1f1iter.InstanceRequirements.LocalStorageTypes {
								var f20f1f1elemf1f14elem string
								f20f1f1elemf1f14elem = string(*f20f1f1elemf1f14iter)
								f20f1f1elemf1f14 = append(f20f1f1elemf1f14, svcsdktypes.LocalStorageType(f20f1f1elemf1f14elem))
							}
							f20f1f1elemf1.LocalStorageTypes = f20f1f1elemf1f14
						}
						if f20f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice != nil {
							maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 := *f20f1f1iter.InstanceRequirements.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice
							if maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 > math.MaxInt32 || maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field MaxSpotPriceAsPercentageOfOptimalOnDemandPrice is of type int32")
							}
							maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy := int32(maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy0)
							f20f1f1elemf1.MaxSpotPriceAsPercentageOfOptimalOnDemandPrice = &maxSpotPriceAsPercentageOfOptimalOnDemandPriceCopy
						}
						if f20f1f1iter.InstanceRequirements.MemoryGiBPerVCPU != nil {
							f20f1f1elemf1f16 := &svcsdktypes.MemoryGiBPerVCpuRequest{}
							if f20f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Max != nil {
								f20f1f1elemf1f16.Max = f20f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Max
							}
							if f20f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Min != nil {
								f20f1f1elemf1f16.Min = f20f1f1iter.InstanceRequirements.MemoryGiBPerVCPU.Min
							}
							f20f1f1elemf1.MemoryGiBPerVCpu = f20f1f1elemf1f16
						}
						if f20f1f1iter.InstanceRequirements.MemoryMiB != nil {
							f20f1f1elemf1f17 := &svcsdktypes.MemoryMiBRequest{}
							if f20f1f1iter.InstanceRequirements.MemoryMiB.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.MemoryMiB.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f17.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.MemoryMiB.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.MemoryMiB.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f17.Min = &minCopy
							}
							f20f1f1elemf1.MemoryMiB = f20f1f1elemf1f17
						}
						if f20f1f1iter.InstanceRequirements.NetworkBandwidthGbps != nil {
							f20f1f1elemf1f18 := &svcsdktypes.NetworkBandwidthGbpsRequest{}
							if f20f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max != nil {
								f20f1f1elemf1f18.Max = f20f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Max
							}
							if f20f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min != nil {
								f20f1f1elemf1f18.Min = f20f1f1iter.InstanceRequirements.NetworkBandwidthGbps.Min
							}
							f20f1f1elemf1.NetworkBandwidthGbps = f20f1f1elemf1f18
						}
						if f20f1f1iter.InstanceRequirements.NetworkInterfaceCount != nil {
							f20f1f1elemf1f19 := &svcsdktypes.NetworkInterfaceCountRequest{}
							if f20f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.NetworkInterfaceCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f19.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.NetworkInterfaceCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f19.Min = &minCopy
							}
							f20f1f1elemf1.NetworkInterfaceCount = f20f1f1elemf1f19
						}
						if f20f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice != nil {
							onDemandMaxPricePercentageOverLowestPriceCopy0 := *f20f1f1iter.InstanceRequirements.OnDemandMaxPricePercentageOverLowestPrice
							if onDemandMaxPricePercentageOverLowestPriceCopy0 > math.MaxInt32 || onDemandMaxPricePercentageOverLowestPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field OnDemandMaxPricePercentageOverLowestPrice is of type int32")
							}
							onDemandMaxPricePercentageOverLowestPriceCopy := int32(onDemandMaxPricePercentageOverLowestPriceCopy0)
							f20f1f1elemf1.OnDemandMaxPricePercentageOverLowestPrice = &onDemandMaxPricePercentageOverLowestPriceCopy
						}
						if f20f1f1iter.InstanceRequirements.RequireHibernateSupport != nil {
							f20f1f1elemf1.RequireHibernateSupport = f20f1f1iter.InstanceRequirements.RequireHibernateSupport
						}
						if f20f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice != nil {
							spotMaxPricePercentageOverLowestPriceCopy0 := *f20f1f1iter.InstanceRequirements.SpotMaxPricePercentageOverLowestPrice
							if spotMaxPricePercentageOverLowestPriceCopy0 > math.MaxInt32 || spotMaxPricePercentageOverLowestPriceCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field SpotMaxPricePercentageOverLowestPrice is of type int32")
							}
							spotMaxPricePercentageOverLowestPriceCopy := int32(spotMaxPricePercentageOverLowestPriceCopy0)
							f20f1f1elemf1.SpotMaxPricePercentageOverLowestPrice = &spotMaxPricePercentageOverLowestPriceCopy
						}
						if f20f1f1iter.InstanceRequirements.TotalLocalStorageGB != nil {
							f20f1f1elemf1f23 := &svcsdktypes.TotalLocalStorageGBRequest{}
							if f20f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max != nil {
								f20f1f1elemf1f23.Max = f20f1f1iter.InstanceRequirements.TotalLocalStorageGB.Max
							}
							if f20f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min != nil {
								f20f1f1elemf1f23.Min = f20f1f1iter.InstanceRequirements.TotalLocalStorageGB.Min
							}
							f20f1f1elemf1.TotalLocalStorageGB = f20f1f1elemf1f23
						}
						if f20f1f1iter.InstanceRequirements.VCPUCount != nil {
							f20f1f1elemf1f24 := &svcsdktypes.VCpuCountRequest{}
							if f20f1f1iter.InstanceRequirements.VCPUCount.Max != nil {
								maxCopy0 := *f20f1f1iter.InstanceRequirements.VCPUCount.Max
								if maxCopy0 > math.MaxInt32 || maxCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Max is of type int32")
								}
								maxCopy := int32(maxCopy0)
								f20f1f1elemf1f24.Max = &maxCopy
							}
							if f20f1f1iter.InstanceRequirements.VCPUCount.Min != nil {
								minCopy0 := *f20f1f1iter.InstanceRequirements.VCPUCount.Min
								if minCopy0 > math.MaxInt32 || minCopy0 < math.MinInt32 {
									return nil, fmt.Errorf("error: field Min is of type int32")
								}
								minCopy := int32(minCopy0)
								f20f1f1elemf1f24.Min = &minCopy
							}
							f20f1f1elemf1.VCpuCount = f20f1f1elemf1f24
						}
						f20f1f1elem.InstanceRequirements = f20f1f1elemf1
					}
					if f20f1f1iter.InstanceType != nil {
						f20f1f1elem.InstanceType = f20f1f1iter.InstanceType
					}
					if f20f1f1iter.LaunchTemplateSpecification != nil {
						f20f1f1elemf3 := &svcsdktypes.LaunchTemplateSpecification{}
						if f20f1f1iter.LaunchTemplateSpecification.LaunchTemplateID != nil {
							f20f1f1elemf3.LaunchTemplateId = f20f1f1iter.LaunchTemplateSpecification.LaunchTemplateID
						}
						if f20f1f1iter.LaunchTemplateSpecification.LaunchTemplateName != nil {
							f20f1f1elemf3.LaunchTemplateName = f20f1f1iter.LaunchTemplateSpecification.LaunchTemplateName
						}
						if f20f1f1iter.LaunchTemplateSpecification.Version != nil {
							f20f1f1elemf3.Version = f20f1f1iter.LaunchTemplateSpecification.Version
						}
						f20f1f1elem.LaunchTemplateSpecification = f20f1f1elemf3
					}
					if f20f1f1iter.WeightedCapacity != nil {
						f20f1f1elem.WeightedCapacity = f20f1f1iter.WeightedCapacity
					}
					f20f1f1 = append(f20f1f1, *f20f1f1elem)
				}
				f20f1.Overrides = f20f1f1
			}
			f20.LaunchTemplate = f20f1
		}
		res.MixedInstancesPolicy = f20
	}
	if r.ko.Spec.NewInstancesProtectedFromScaleIn != nil {
		res.NewInstancesProtectedFromScaleIn = r.ko.Spec.NewInstancesProtectedFromScaleIn
	}
	if r.ko.Spec.PlacementGroup != nil {
		res.PlacementGroup = r.ko.Spec.PlacementGroup
	}
	if r.ko.Spec.ServiceLinkedRoleARN != nil {
		res.ServiceLinkedRoleARN = r.ko.Spec.ServiceLinkedRoleARN
	}
	if r.ko.Spec.SkipZonalShiftValidation != nil {
		res.SkipZonalShiftValidation = r.ko.Spec.SkipZonalShiftValidation
	}
	if r.ko.Spec.TerminationPolicies != nil {
		res.TerminationPolicies = aws.ToStringSlice(r.ko.Spec.TerminationPolicies)
	}
	if r.ko.Spec.VPCZoneIdentifier != nil {
		res.VPCZoneIdentifier = r.ko.Spec.VPCZoneIdentifier
	}

	return res, nil
}

// sdkDelete deletes the supplied resource in the backend AWS service API
func (rm *resourceManager) sdkDelete(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkDelete")
	defer func() {
		exit(err)
	}()
	input, err := rm.newDeleteRequestPayload(r)
	if err != nil {
		return nil, err
	}
	var resp *svcsdk.DeleteAutoScalingGroupOutput
	_ = resp
	resp, err = rm.sdkapi.DeleteAutoScalingGroup(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "DeleteAutoScalingGroup", err)
	return nil, err
}

// newDeleteRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Delete API call for the resource
func (rm *resourceManager) newDeleteRequestPayload(
	r *resource,
) (*svcsdk.DeleteAutoScalingGroupInput, error) {
	res := &svcsdk.DeleteAutoScalingGroupInput{}

	if r.ko.Spec.AutoScalingGroupName != nil {
		res.AutoScalingGroupName = r.ko.Spec.AutoScalingGroupName
	}

	return res, nil
}

// setStatusDefaults sets default properties into supplied custom resource
func (rm *resourceManager) setStatusDefaults(
	ko *svcapitypes.AutoScalingGroup,
) {
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if ko.Status.ACKResourceMetadata.Region == nil {
		ko.Status.ACKResourceMetadata.Region = &rm.awsRegion
	}
	if ko.Status.ACKResourceMetadata.OwnerAccountID == nil {
		ko.Status.ACKResourceMetadata.OwnerAccountID = &rm.awsAccountID
	}
	if ko.Status.Conditions == nil {
		ko.Status.Conditions = []*ackv1alpha1.Condition{}
	}
}

// updateConditions returns updated resource, true; if conditions were updated
// else it returns nil, false
func (rm *resourceManager) updateConditions(
	r *resource,
	onSuccess bool,
	err error,
) (*resource, bool) {
	ko := r.ko.DeepCopy()
	rm.setStatusDefaults(ko)

	// Terminal condition
	var terminalCondition *ackv1alpha1.Condition = nil
	var recoverableCondition *ackv1alpha1.Condition = nil
	var syncCondition *ackv1alpha1.Condition = nil
	for _, condition := range ko.Status.Conditions {
		if condition.Type == ackv1alpha1.ConditionTypeTerminal {
			terminalCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeRecoverable {
			recoverableCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeResourceSynced {
			syncCondition = condition
		}
	}
	var termError *ackerr.TerminalError
	if rm.terminalAWSError(err) || err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
		if terminalCondition == nil {
			terminalCondition = &ackv1alpha1.Condition{
				Type: ackv1alpha1.ConditionTypeTerminal,
			}
			ko.Status.Conditions = append(ko.Status.Conditions, terminalCondition)
		}
		var errorMessage = ""
		if err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
			errorMessage = err.Error()
		} else {
			awsErr, _ := ackerr.AWSError(err)
			errorMessage = awsErr.Error()
		}
		terminalCondition.Status = corev1.ConditionTrue
		terminalCondition.Message = &errorMessage
	} else {
		// Clear the terminal condition if no longer present
		if terminalCondition != nil {
			terminalCondition.Status = corev1.ConditionFalse
			terminalCondition.Message = nil
		}
		// Handling Recoverable Conditions
		if err != nil {
			if recoverableCondition == nil {
				// Add a new Condition containing a non-terminal error
				recoverableCondition = &ackv1alpha1.Condition{
					Type: ackv1alpha1.ConditionTypeRecoverable,
				}
				ko.Status.Conditions = append(ko.Status.Conditions, recoverableCondition)
			}
			recoverableCondition.Status = corev1.ConditionTrue
			awsErr, _ := ackerr.AWSError(err)
			errorMessage := err.Error()
			if awsErr != nil {
				errorMessage = awsErr.Error()
			}
			recoverableCondition.Message = &errorMessage
		} else if recoverableCondition != nil {
			recoverableCondition.Status = corev1.ConditionFalse
			recoverableCondition.Message = nil
		}
	}
	// Required to avoid the "declared but not used" error in the default case
	_ = syncCondition
	if terminalCondition != nil || recoverableCondition != nil || syncCondition != nil {
		return &resource{ko}, true // updated
	}
	return nil, false // not updated
}

// terminalAWSError returns awserr, true; if the supplied error is an aws Error type
// and if the exception indicates that it is a Terminal exception
// 'Terminal' exception are specified in generator configuration
func (rm *resourceManager) terminalAWSError(err error) bool {
	// No terminal_errors specified for this resource in generator config
	return false
}
